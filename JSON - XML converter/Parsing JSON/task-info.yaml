type: edu
custom_name: stage4
files:
- name: src/converter/Main.java
  visible: true
  text: |
    package converter;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
  learner_created: false
- name: test/ConverterTest.java
  visible: false
  text: |
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.StandardCopyOption;
    import java.util.List;
    import java.util.regex.Pattern;

    import static java.util.stream.Collectors.toUnmodifiableList;
    import static util.Assert.assertEquals;
    import static util.Assert.assertFalse;

    public class ConverterTest extends StageTest {
        private static final Pattern ELEMENTS_DELIMITER = Pattern
                .compile("\\s+(?=Element:)", Pattern.CASE_INSENSITIVE);

        final int[] testCases = {1, 2, 3, 4};

        @DynamicTest(data = "testCases")
        CheckResult simpleTest(final int testCase) throws IOException {
            Files.copy(
                    Path.of("test/data/test" + testCase + ".json"),
                    Path.of("test.txt"),
                    StandardCopyOption.REPLACE_EXISTING);

            final var expectedOutput = Files.readString(
                    Path.of("test/data/expected" + testCase + ".txt"));
            final var expectedElements = parseOutput(expectedOutput);

            final var program = new TestedProgram();
            final var actualOutput = program.start();

            assertFalse(actualOutput.isBlank(), "empty");
            final var actualElements = parseOutput(actualOutput);

            assertFalse(actualElements.size() < expectedElements.size(),
                    "lessElements", actualElements.size(), expectedElements.size());

            assertFalse(actualElements.size() < expectedElements.size(),
                    "moreElements", actualElements.size(), expectedElements.size());

            for (int i = 0; i < expectedElements.size(); ++i) {
                assertEquals(expectedElements.get(i), expectedElements.get(i),
                        "elementsNotEqual", i + 1, expectedElements.get(i));
            }

            return CheckResult.correct();
        }

        private List<Element> parseOutput(final String data) {
            return ELEMENTS_DELIMITER
                    .splitAsStream(data)
                    .map(Element::parse)
                    .collect(toUnmodifiableList());
        }

    }
  learner_created: false
- name: test/Element.java
  visible: false
  text: |
    import java.util.Collections;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Objects;
    import java.util.function.Consumer;
    import java.util.regex.Pattern;

    import static java.util.function.Predicate.not;
    import static java.util.stream.Collectors.toUnmodifiableList;
    import static util.Assert.*;

    public class Element {
        private static final Pattern PATH_PATTERN = Pattern
                .compile("^path\\s*=\\s*(?<path>\\w+(?:, \\w+)*)\\s*", Pattern.CASE_INSENSITIVE);

        private static final Pattern VALUE_PATTERN = Pattern
                .compile("^value\\s*=\\s*(?<value>null|\".*\")\\s*", Pattern.CASE_INSENSITIVE);

        private static final Pattern ATTRIBUTE_PATTERN = Pattern
                .compile("(?<key>\\w+)\\s*=\\s*\"(?<value>.*)\"", Pattern.CASE_INSENSITIVE);

        private static final Pattern THIRD_PATTERN = Pattern
                .compile("^(?<keyword>value|attributes).*", Pattern.CASE_INSENSITIVE);

        private final String path;
        private final ElementValue value;
        private final Map<String, String> attributes;

        public Element(final String path) {
            this(path, ElementValue.ABSENT);
        }

        public Element(final String path, final ElementValue value) {
            this(path, value, Collections.emptyMap());
        }

        public Element(final String path, final ElementValue value, final Map<String, String> attributes) {
            this.path = path;
            this.value = value;
            this.attributes = attributes;
        }

        public static Element parse(final String data) {
            final var elementLines = data.lines()
                    .filter(not(String::isBlank))
                    .map(String::strip)
                    .collect(toUnmodifiableList());

            assertTrue(elementLines.size() > 1, "minimumTwoLines");

            final var lines = elementLines.iterator();

            final var first = lines.next();
            assertTrue(first.startsWith("Element:"), "startElement", first);

            final var second = lines.next();
            assertTrue(second.startsWith("path"), "startPath", second);

            final var pathRecord = PATH_PATTERN.matcher(second);
            assertTrue(pathRecord.matches(), "pathPattern", second);
            final var path = pathRecord.group("path");

            if (!lines.hasNext()) {
                return new Element(path);
            }

            final var third = lines.next();
            final var keyRecord = THIRD_PATTERN.matcher(third);
            assertTrue(keyRecord.matches(), "thirdLine", third);
            final var keyword = keyRecord.group("keyword");

            final ElementValue value;

            if ("value".equalsIgnoreCase(keyword)) {
                final var record = VALUE_PATTERN.matcher(third);
                assertTrue(record.matches(), "valuePattern", third);
                value = ElementValue.parse(record.group("value"));
                if (!lines.hasNext()) {
                    return new Element(path, value);
                }
                assertTrue(lines.next().startsWith("attributes"), "startAttributes");
            } else {
                value = ElementValue.ABSENT;
            }

            assertTrue(lines.hasNext(), "noAttributes");

            final var attributes = new HashMap<String, String>();

            final Consumer<String> parseAttribute = line -> {
                final var record = ATTRIBUTE_PATTERN.matcher(line);
                assertTrue(record.matches(), "attributePattern", line);
                attributes.put(record.group("key"), record.group("value"));
            };

            lines.forEachRemaining(parseAttribute);

            return new Element(path, value, attributes);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Element element = (Element) o;
            return path.equals(element.path)
                    && value.equals(element.value)
                    && attributes.equals(element.attributes);
        }

        @Override
        public int hashCode() {
            return Objects.hash(path, value, attributes);
        }

        @Override
        public String toString() {
            final var output = new StringBuilder("Element:\npath = " + path + '\n' + value);
            if (!attributes.isEmpty()) {
                output.append("attributes:\n");
                attributes.forEach((key, value) -> output.append(key + " = \"" + value + "\"\n"));
            }
            return output.toString();
        }
    }
  learner_created: false
- name: test/ElementValue.java
  visible: false
  text: |
    import java.util.Objects;
    import java.util.regex.Pattern;

    public class ElementValue {
        public static final ElementValue ABSENT = new ElementValue(Type.ABSENT);
        public static final ElementValue NULL = new ElementValue(Type.NULL);

        private static final Pattern TEXT_PATTERN = Pattern.compile("^\"?(?<text>.*?)\"?$");
        private final Type type;
        private final String text;

        public ElementValue(final Type type) {
            this.type = type;
            text = null;
        }

        public ElementValue(final String text) {
            this.type = Type.TEXT;
            this.text = text;
        }

        public static ElementValue parse(final String value) {
            if ("null".equalsIgnoreCase(value)) {
                return NULL;
            }
            final var text = TEXT_PATTERN.matcher(value).replaceFirst("${text}");
            return new ElementValue(text);
        }

        enum Type {
            ABSENT, NULL, TEXT
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            ElementValue that = (ElementValue) o;
            return type == that.type && Objects.equals(text, that.text);
        }

        @Override
        public int hashCode() {
            return Objects.hash(type, text);
        }

        @Override
        public String toString() {
            switch (type) {
                case ABSENT:
                    return "";
                case NULL:
                    return "value = null\n";
                default:
                    return "value = \"" + text + "\"\n";
            }
        }
    }
  learner_created: false
- name: test/Messages.java
  visible: false
  text: |-
    import java.util.ListResourceBundle;

    public class Messages extends ListResourceBundle {
        @Override
        protected Object[][] getContents() {
            return new Object[][]{
                    {"empty", "Your output is empty line."},
                    {"minimumTwoLines",
                            "Every element block should contains minimum two lines."},
                    {"startElement",
                            "The first line of element block should starts with \"Element\" keyword.\n"
                                    + "Found the first line: \"{0}\"."},
                    {"startPath",
                            "The second line of element block should starts with \"path\" keyword.\n"
                                    + "Found the second line in the block: \"{0}\"."},
                    {"pathPattern",
                            "The path of element should be in the format: \"path = tag0, tag1, ..., tagN\"\n"
                                    + "Found the path in format: \"{0}\"."},
                    {"thirdLine",
                            "The third line of block should starts with keywords 'value' or 'attributes'.\n"
                                    + "Found the third line: {0}."},
                    {"valuePattern",
                            "The value of element should be in the format:\n"
                                    + "value = \"...\" or value = null\n" + "Found: {0}."},
                    {"startAttributes",
                            "The line after value should starts with \"attributes\" keyword.\n"
                                    + "Found the line after the \"value\": \"{0}\"."},
                    {"noAttributes",
                            "After keyword \"attributes\" should be at least one attribute.\n"
                                    + "If an element doesn't have attributes the program "
                                    + "should skip printing the keyword \"attributes\" for that element."},
                    {"attributePattern",
                            "The attribute of element should be in the format:\n"
                                    + "key = \"value\"" + "Found: {0}."},

                    {"lessElements",
                            "The number of elements is less then expected.\n"
                                    + "The program outputs only {0} elements but expected {1}."},
                    {"moreElements",
                            "The number of elements is more then expected.\n"
                                    + "The program outputs {0} elements but expected only {1}."},
                    {"elementsNotEqual",
                            "The element number {0} is not equals to expected.\n"
                                    + "The expected output for element #{0} is\n{1}"},
            };
        }
    }
  learner_created: false
- name: test/data/expected1.txt
  visible: false
  text: |
    Element:
    path = transaction

    Element:
    path = transaction, id
    value = "6753322"

    Element:
    path = transaction, number
    value = "8-900-000-000"
    attributes:
    region = "Russia"

    Element:
    path = transaction, empty1
    value = null

    Element:
    path = transaction, empty2
    value = ""

    Element:
    path = transaction, empty3
    value = ""

    Element:
    path = transaction, inner1

    Element:
    path = transaction, inner1, inner2

    Element:
    path = transaction, inner1, inner2, inner3

    Element:
    path = transaction, inner1, inner2, inner3, key1
    value = "value1"

    Element:
    path = transaction, inner1, inner2, inner3, key2
    value = "value2"

    Element:
    path = transaction, inner4

    Element:
    path = transaction, inner4, inner4
    value = "value3"

    Element:
    path = transaction, inner5

    Element:
    path = transaction, inner5, attr1
    value = "123.456"

    Element:
    path = transaction, inner5, inner4
    value = "value4"

    Element:
    path = transaction, inner6
    value = "value5"
    attributes:
    attr2 = "789.321"

    Element:
    path = transaction, inner7
    value = "value6"

    Element:
    path = transaction, inner8

    Element:
    path = transaction, inner8, attr3
    value = "value7"

    Element:
    path = transaction, inner9

    Element:
    path = transaction, inner9, attr4
    value = "value8"

    Element:
    path = transaction, inner9, inner9
    value = "value9"

    Element:
    path = transaction, inner9, something
    value = "value10"

    Element:
    path = transaction, inner10
    value = null
    attributes:
    attr5 = ""

    Element:
    path = transaction, inner11
    value = ""

    Element:
    path = transaction, inner12

    Element:
    path = transaction, inner12, somekey
    value = "keyvalue"

    Element:
    path = transaction, inner12, inner12
    value = "notnull"

    Element:
    path = meta

    Element:
    path = meta, version
    value = "0.01"
  learner_created: false
- name: test/data/expected2.txt
  visible: false
  text: |
    Element:
    path = root1
    attributes:
    attr1 = "val1"
    attr2 = "val2"

    Element:
    path = root1, elem1
    value = "Value1"
    attributes:
    attr3 = "val3"
    attr4 = "val4"

    Element:
    path = root1, elem2
    value = "Value2"
    attributes:
    attr5 = "val5"
    attr6 = "val6"

    Element:
    path = root2
    value = null
    attributes:
    attr1 = ""
    attr2 = ""

    Element:
    path = root3
    value = ""
    attributes:
    attr1 = "val2"
    attr2 = "val1"

    Element:
    path = root4
    value = "Value4"
  learner_created: false
- name: test/data/expected3.txt
  visible: false
  text: |
    Element:
    path = root1
    attributes:
    attr1 = "val1"
    attr2 = "val2"

    Element:
    path = root1, elem1
    value = "Value1"
    attributes:
    attr3 = "val3"
    attr4 = "val4"

    Element:
    path = root1, elem2
    value = "Value2"
    attributes:
    attr5 = "val5"
    attr6 = "val6"

    Element:
    path = root2
    value = null
    attributes:
    attr1 = ""
    attr2 = ""

    Element:
    path = root3
    value = ""
    attributes:
    attr1 = "val2"
    attr2 = "val1"

    Element:
    path = root4
    value = "Value4"
  learner_created: false
- name: test/data/expected4.txt
  visible: false
  text: |
    Element:
    path = transaction

    Element:
    path = transaction, id
    value = "13243547"

    Element:
    path = transaction, number
    value = "8-900-000-999"
    attributes:
    region = "USA"

    Element:
    path = transaction, inner1

    Element:
    path = transaction, inner1, inner2

    Element:
    path = transaction, inner1, inner2, inner3

    Element:
    path = transaction, inner1, inner2, inner3, key1
    value = "value1"

    Element:
    path = transaction, inner1, inner2, inner3, key2
    value = "value2"

    Element:
    path = transaction, inner4

    Element:
    path = transaction, inner4, inner4
    value = "value3"

    Element:
    path = transaction, inner5

    Element:
    path = transaction, inner5, attr1
    value = "123.456"

    Element:
    path = transaction, inner5, inner4
    value = "value4"

    Element:
    path = transaction, inner6
    value = "value5"
    attributes:
    attr2 = "789.321"

    Element:
    path = transaction, inner7
    value = "value6"

    Element:
    path = transaction, inner8

    Element:
    path = transaction, inner8, attr3
    value = "value7"

    Element:
    path = transaction, inner9

    Element:
    path = transaction, inner9, attr4
    value = "value8"

    Element:
    path = transaction, inner9, inner9
    value = "value9"

    Element:
    path = transaction, inner9, something
    value = "value10"

    Element:
    path = transaction, inner10
    value = null
    attributes:
    attr5 = ""

    Element:
    path = transaction, inner11
    value = ""

    Element:
    path = transaction, inner12

    Element:
    path = transaction, inner12, somekey
    value = "keyvalue"

    Element:
    path = transaction, inner12, inner12
    value = "notnull"

    Element:
    path = meta

    Element:
    path = meta, version
    value = "0.01"
  learner_created: false
- name: test/data/test1.json
  visible: false
  text: |
    {
        "transaction": {
            "id": "6753322",
            "number": {
                "@region": "Russia",
                "#number": "8-900-000-000"
            },
            "empty1": null,
            "empty2": { },
            "empty3": "",
            "inner1": {
                "inner2": {
                    "inner3": {
                        "key1": "value1",
                        "key2": "value2"
                    }
                }
            },
            "inner4": {
                "@": 123,
                "#inner4": "value3"
            },
            "inner5": {
                "@attr1": 123.456,
                "#inner4": "value4"
            },
            "inner6": {
                "@attr2": 789.321,
                "#inner6": "value5"
            },
            "inner7": {
                "#inner7": "value6"
            },
            "inner8": {
                "@attr3": "value7"
            },
            "inner9": {
                "@attr4": "value8",
                "#inner9": "value9",
                "something": "value10"
            },
            "inner10": {
                "@attr5": null,
                "#inner10": null
            },
            "inner11": {
                "@": null,
                "#": null
            },
            "inner12": {
                "@somekey": "attrvalue",
                "#inner12": null,
                "somekey": "keyvalue",
                "inner12": "notnull"
            },
            "": {
                "#": null,
                "secret": "this won't be converted"
            }
        },
        "meta": {
            "version": 0.01
        }
    }
  learner_created: false
- name: test/data/test2.json
  visible: false
  text: |+
    {
        "root1": {
            "@attr1": "val1",
            "@attr2": "val2",
            "#root1": {
                "elem1": {
                    "@attr3": "val3",
                    "@attr4": "val4",
                    "#elem1": "Value1"
                },
                "elem2": {
                    "@attr5": "val5",
                    "@attr6": "val6",
                    "#elem2": "Value2"
                }
            }
        },
        "root2": {
            "@attr1": null,
            "@attr2": "",
            "#root2": null
        },
        "root3": {
            "@attr1": "val2",
            "@attr2": "val1",
            "#root3": ""
        },
        "root4": "Value4"
    }

  learner_created: false
- name: test/data/test3.json
  visible: false
  text: '{"root1":{"@attr1":"val1","@attr2":"val2","#root1":{"elem1":{"@attr3":"val3","@attr4":"val4","#elem1":"Value1"},"elem2":{"@attr5":"val5","@attr6":"val6","#elem2":"Value2"}}},"root2":{"@attr1":null,"@attr2":"","#root2":null},"root3":{"@attr1":"val2","@attr2":"val1","#root3":""},"root4":"Value4"}'
  learner_created: false
- name: test/data/test4.json
  visible: false
  text: |
    {
        "transaction": {
            "id": "13243547",
            "number": {
                "@region": "USA",
                "#number": "8-900-000-999"
            },
            "inner1": {
                "inner2": {
                    "inner3": {
                        "key1": "value1",
                        "key2": "value2"
                    }
                }
            },
            "inner4": {
                "@": 123,
                "#inner4": "value3"
            },
            "inner5": {
                "@attr1": 123.456,
                "#inner4": "value4"
            },
            "inner6": {
                "@attr2": 789.321,
                "#inner6": "value5"
            },
            "inner7": {
                "#inner7": "value6"
            },
            "inner8": {
                "@attr3": "value7"
            },
            "inner9": {
                "@attr4": "value8",
                "#inner9": "value9",
                "something": "value10"
            },
            "inner10": {
                "@attr5": null,
                "#inner10": null
            },
            "inner11": {
                "@": null,
                "#": null
            },
            "inner12": {
                "@somekey": "attrvalue",
                "#inner12": null,
                "somekey": "keyvalue",
                "inner12": "notnull"
            },
            "": {
                "#": null,
                "secret": "this won't be converted"
            }
        },
        "meta": {
            "version": 0.01
        }
    }
  learner_created: false
- name: test/util/Assert.java
  visible: false
  text: |-
    package util;

    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;

    import java.util.ResourceBundle;
    import java.util.regex.Pattern;

    import static java.text.MessageFormat.format;

    public class Assert {
        private static final ResourceBundle messages = ResourceBundle.getBundle("Messages");

        public static void assertEquals(
                final Object expected,
                final Object actual,
                final String error,
                final Object... args) {

            if (!expected.equals(actual)) {
                final var feedback = format(messages.getString(error), args);
                throw new WrongAnswer(feedback);
            }
        }

        public static void assertMatches(
                final String pattern,
                final String actual,
                final String error,
                final Object... args) {

            if (!actual.matches(pattern)) {
                final var feedback = format(messages.getString(error), args);
                throw new WrongAnswer(feedback);
            }
        }

        public static void assertMatches(
                final Pattern pattern,
                final String actual,
                final String error,
                final Object... args) {

            if (!pattern.matcher(actual).matches()) {
                final var feedback = format(messages.getString(error), args);
                throw new WrongAnswer(feedback);
            }
        }

        public static void assertTrue(
                final boolean condition,
                final String error,
                final Object... args) {
            if (!condition) {
                final var feedback = format(messages.getString(error), args);
                throw new WrongAnswer(feedback);
            }
        }

        public static void assertFalse(
                final boolean condition,
                final String error,
                final Object... args) {
            if (condition) {
                final var feedback = format(messages.getString(error), args);
                throw new WrongAnswer(feedback);
            }
        }
    }
  learner_created: false
- name: src/converter/JSONComponents/JSONNumber.java
  visible: true
  text: |2-

    package converter.JSONComponents;

    public abstract class JSONNumber implements JSONComponent {
    }
  learner_created: true
- name: src/converter/XMLComponents/XMLComponent.java
  visible: true
  text: |2-

    package converter.XMLComponents;

    //Marker interface, same as JSON counterpart
    public interface XMLComponent {
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONBoolean.java
  visible: true
  text: |2-

    package converter.JSONComponents;

    public class JSONBoolean implements JSONComponent {
        private final boolean bool;

        public JSONBoolean(boolean bool) {
            this.bool = bool;
        }

        @Override
        public String toString() {
            return JSONRepresentation();
        }

        @Override
        public String JSONRepresentation() {
            return Boolean.toString(bool);
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONFloat.java
  visible: true
  text: |2-

    package converter.JSONComponents;

    public class JSONFloat extends JSONNumber {
        private final double num;

        public JSONFloat(double num) {
            this.num = num;
        }

        @Override
        public String toString() {
            return JSONRepresentation();
        }

        @Override
        public String JSONRepresentation() {
            return Double.toString(num);
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONString.java
  visible: true
  text: |2-

    package converter.JSONComponents;

    public class JSONString implements JSONComponent{
        private final String str;

        public JSONString(String str) {
            this.str = str;
        }

        @Override
        public String toString() {
            return str;
        }

        @Override
        public int hashCode() {
            return str.hashCode();
        }

        @Override
        public String JSONRepresentation() {
            return '"' + str + '"';
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONInteger.java
  visible: true
  text: |2-

    package converter.JSONComponents;

    public class JSONInteger extends JSONNumber {
        private final int num;

        public JSONInteger(int num) {
            this.num = num;
        }

        @Override
        public String toString() {
            return JSONRepresentation();
        }

        @Override
        public String JSONRepresentation() {
            return Integer.toString(num);
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONComponent.java
  visible: true
  text: |-
    package converter.JSONComponents;

    //Interface so JSONCharacter enum can be in the same list...not ideal, but AFAIK Java doesn't have an equivalent
    //of the C++ variant library template...
    public interface JSONComponent {
        String JSONRepresentation();

        default boolean isJSONPrimitive() {
            return true;
        }

        default boolean isJSONArray() {
            return false;
        }

        default boolean isJSONObject() {
            return false;
        }
    }
  learner_created: true
- name: src/converter/XMLComponents/XMLSyntax.java
  visible: true
  text: |-
    package converter.XMLComponents;

    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Optional;
    import java.util.function.Function;
    import java.util.stream.Collectors;

    public enum XMLSyntax implements XMLComponent {
        XML_EQUALS('='),
        XML_QUOTE('"'),
        XML_LEFT_ANGLE_BRACKET('<'),
        XML_RIGHT_ANGLE_BRACKET('>'),
        XML_FORWARD_SLASH('/');

        private static HashMap<Character, XMLSyntax> charMapping = Arrays.stream(XMLSyntax.values())
                .collect(Collectors.toMap(XMLSyntax::getField, Function.identity(), (e, r) -> e, HashMap::new));

        private char field;

        XMLSyntax(char field) {
            this.field = field;
        }

        public char getField() {
            return field;
        }

        public static Optional<XMLSyntax> getByField(char field) {
            return Optional.ofNullable(charMapping.get(field));
        }

    }
  learner_created: true
- name: src/converter/Pair.java
  visible: true
  text: |2-

    package converter;

    public class Pair<T, U> {
        private final T t;
        private final U u;

        public Pair(T t, U u) {
            this.t = t;
            this.u = u;
        }

        public T getFirst() {
            return t;
        }

        public U getSecond() {
            return u;
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONNull.java
  visible: true
  text: |2-

    package converter.JSONComponents;

    public class JSONNull implements JSONComponent{
        @Override
        public String toString() {
            return null;
        }

        @Override
        public String JSONRepresentation() {
            return null;
        }
    }
  learner_created: true
- name: src/converter/XMLComponents/XMLContentString.java
  visible: true
  text: |-
    package converter.XMLComponents;

    public class XMLContentString extends XMLContent {
        private String contentString;

        public XMLContentString(String contentString) {
            this.contentString = contentString;
        }

        public String getContentString() {
            return contentString;
        }

        public void setContentString(String contentString) {
            this.contentString = contentString;
        }

        @Override
        public boolean isContentString() {
            return true;
        }

        @Override
        public String toString() {
            return "\"" + contentString + "\"";
        }
    }
  learner_created: true
- name: src/converter/XMLComponents/XMLContent.java
  visible: true
  text: |2-

    package converter.XMLComponents;

    public abstract class XMLContent implements  XMLComponent{
        public boolean isTag() {
            return false;
        }

        public boolean isContentString() {
            return false;
        }
    }
  learner_created: true
- name: src/converter/XMLParser/XMLParser.java
  visible: true
  text: |-
    package converter.XMLParser;

    import converter.Pair;
    import converter.XMLComponents.XMLAttribute;
    import converter.XMLComponents.XMLContent;
    import converter.XMLComponents.XMLContentString;
    import converter.XMLComponents.XMLSyntax;
    import converter.XMLComponents.XMLTag;

    import java.util.ArrayList;
    import java.util.HashSet;
    import java.util.stream.Collectors;
    import java.util.stream.Stream;

    public class XMLParser {
        private static final HashSet<Character> whiteSpace = Stream.of(' ', '\t', '\b', '\n', '\r')
                .collect(Collectors.toCollection(HashSet::new));

        public static Pair<? extends XMLContent, Integer> parse(String XML, int currentPos) {
            //Handle possible invalid input
            if (XML.isEmpty() || XML.isBlank())
                throw new IllegalArgumentException("Invalid XML passed: " + XML);
            else if (currentPos >= XML.length())
                throw new IllegalArgumentException("Invalid currentPos: " + currentPos + " but XML length is: " + XML.length());

            var current = XMLSyntax.getByField(XML.charAt(currentPos));
            var next = XMLSyntax.getByField(XML.charAt(currentPos + 1));
            if (current.isPresent() && current.get() == XMLSyntax.XML_LEFT_ANGLE_BRACKET
                    && next.isEmpty())
                return parseTag(XML, currentPos);
            else if (current.isPresent() && current.get() == XMLSyntax.XML_LEFT_ANGLE_BRACKET
                    && next.get() == XMLSyntax.XML_FORWARD_SLASH) {
                return null;
            } else {
                StringBuilder content = new StringBuilder();
                //append until encountering start closing tag
                while (!(current.isPresent() && current.get() == XMLSyntax.XML_LEFT_ANGLE_BRACKET
                        && next.isPresent() && next.get() == XMLSyntax.XML_FORWARD_SLASH)) {
                    content.append(XML.charAt(currentPos));
                    ++currentPos;
                    current = XMLSyntax.getByField(XML.charAt(currentPos));
                    next = XMLSyntax.getByField(XML.charAt(currentPos + 1));
                }
                return new Pair<>(new XMLContentString(content.toString()), currentPos);
            }
        }

        //Invoke upon encountering '<'
        public static Pair<XMLTag, Integer> parseTag(String XML, int currentPos) {
            //Handle possible invalid input
            if (XML.isEmpty() || XML.isBlank())
                throw new IllegalArgumentException("Invalid XML passed: " + XML);
            else if (currentPos >= XML.length())
                throw new IllegalArgumentException("Invalid currentPos: " + currentPos + " but XML length is: " + XML.length());
            else if (XMLSyntax.getByField(XML.charAt(currentPos)).get() != XMLSyntax.XML_LEFT_ANGLE_BRACKET)
                throw new IllegalArgumentException("charAt currentPos of XML is: " + XML.charAt(currentPos) + " but parsed tag must" +
                        " begin with '<'!");
            ++currentPos;

            XMLTag tag = new XMLTag();
            //Discard any whitespace up to first string, which should be element
            currentPos = discardWhitespace(XML, currentPos);
            StringBuilder element = new StringBuilder();
            while (!whiteSpace.contains(XML.charAt(currentPos)) && XMLSyntax.getByField(XML.charAt(currentPos)).isEmpty()) {
                element.append(XML.charAt(currentPos));
                ++currentPos;
            }
            tag.setElement(element.toString());
            currentPos = discardWhitespace(XML, currentPos);

            //need to parse attributes
            if (XMLSyntax.getByField(XML.charAt(currentPos)).isEmpty()) {
                var current = XMLSyntax.getByField(XML.charAt(currentPos));
                while (current.isEmpty()
                        || (current.get() != XMLSyntax.XML_RIGHT_ANGLE_BRACKET
                        && current.get() != XMLSyntax.XML_FORWARD_SLASH)) {
                    XMLAttribute attr = new XMLAttribute();
                    StringBuilder attribute = new StringBuilder();
                    while (!(whiteSpace.contains(XML.charAt(currentPos)) || XML.charAt(currentPos) == '=')) {
                        attribute.append(XML.charAt(currentPos));
                        ++currentPos;
                    }
                    attr.setAttribute(attribute.toString());
                    currentPos = discardWhitespace(XML, currentPos);
                    if (XML.charAt(currentPos) != '=')
                        throw new IllegalArgumentException("Expected '=' between attribute and value, found " + XML.charAt(currentPos));
                    ++currentPos;
                    currentPos = discardWhitespace(XML, currentPos);
                    if (XML.charAt(currentPos) != '"')
                        throw new IllegalArgumentException("Expected '\"' to surround attribute value, found " + XML.charAt(currentPos));
                    StringBuilder value = new StringBuilder();
                    ++currentPos;
                    while (XML.charAt(currentPos) != '"') {
                        value.append(XML.charAt(currentPos));
                        ++currentPos;
                    }
                    ++currentPos;
                    currentPos = discardWhitespace(XML, currentPos);
                    attr.setValue(value.toString());
                    if (tag.hasAttributes())
                        tag.getAttributes().add(attr);
                    else
                        tag.setAttributes(Stream.of(attr).collect(Collectors.toCollection(ArrayList::new)));
                    current = XMLSyntax.getByField(XML.charAt(currentPos));
                }
            }

            //Handle content, if any
            if (XMLSyntax.getByField(XML.charAt(currentPos)).get() == XMLSyntax.XML_FORWARD_SLASH
                    && XMLSyntax.getByField(XML.charAt(currentPos + 1)).isPresent()
                    && XMLSyntax.getByField(XML.charAt(currentPos + 1)).get() == XMLSyntax.XML_RIGHT_ANGLE_BRACKET) //no content
                return new Pair<>(tag, currentPos + 2);
            else if (XMLSyntax.getByField(XML.charAt(currentPos)).get() == XMLSyntax.XML_RIGHT_ANGLE_BRACKET) { //content to parse
                // System.out.println("Parsing from element: " + element + " currentpos: " + currentPos  + " " + XML.substring(currentPos));
                currentPos = discardWhitespace(XML, ++currentPos);
                var content = parse(XML, currentPos);
                if (content == null)  //empty tag case
                    tag.setContent(new ArrayList<>());
                else {
                    tag.addContent(content.getFirst());
                    currentPos = discardWhitespace(XML, content.getSecond());
                }
                var current = XMLSyntax.getByField(XML.charAt(currentPos));
                var next = XMLSyntax.getByField(XML.charAt(currentPos + 1));
                while (!(current.isPresent() && current.get() == XMLSyntax.XML_LEFT_ANGLE_BRACKET
                        && next.isPresent() && next.get() == XMLSyntax.XML_FORWARD_SLASH
                        && XML.substring(currentPos + 2, currentPos + 2 + tag.getElement().length()).equals(tag.getElement()))) {
                    //System.out.println("Parsing from element: " + element + " currentpos: " + currentPos  + " " + XML.substring(currentPos));
                    //System.out.println("Content: " + tag.getContent());
                    content = parse(XML, currentPos);
                    tag.addContent(content.getFirst());
                    currentPos = discardWhitespace(XML, content.getSecond());
                    current = XMLSyntax.getByField(XML.charAt(currentPos));
                    next = XMLSyntax.getByField(XML.charAt(currentPos + 1));
                }
                //currentPos is now at the '<' position of the tag's closing tag, so need to iterate to end
                while (!(current.isPresent() && current.get() == XMLSyntax.XML_RIGHT_ANGLE_BRACKET)) {
                    ++currentPos;
                    current = XMLSyntax.getByField(XML.charAt(currentPos));
                }
                return new Pair<>(tag, ++currentPos);
            } else
                throw new IllegalArgumentException("Expected tag to close!");
        }

        private static int discardWhitespace(String XML, int currentPos) {
            while (whiteSpace.contains(XML.charAt(currentPos)))
                ++currentPos;
            return currentPos;
        }
    }
  learner_created: true
- name: src/converter/XMLComponents/XMLAttribute.java
  visible: true
  text: |-
    package converter.XMLComponents;

    public class XMLAttribute implements XMLComponent {
        private String attribute;
        private String value;

        public XMLAttribute() {}

        public XMLAttribute(String attribute, String value) {
            this.attribute = attribute;
            this.value = value;
        }

        public String getAttribute() {
            return attribute;
        }

        public void setAttribute(String attribute) {
            this.attribute = attribute;
        }

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(attribute);
            sb.append(" = ");
            sb.append('"');
            sb.append(value);
            sb.append('"');
            return sb.toString();
        }
    }
  learner_created: true
- name: src/converter/XMLComponents/XMLTag.java
  visible: true
  text: |-
    package converter.XMLComponents;

    import java.util.ArrayList;

    public class XMLTag extends XMLContent {
        private String element;
        private ArrayList<XMLAttribute> attributes;
        private ArrayList<XMLContent> content;

        public String getElement() {
            return element;
        }

        public void setElement(String element) {
            this.element = element;
        }

        public boolean hasAttributes() {
            return attributes != null;
        }

        public void addAttribute(XMLAttribute attribute) {
            if (attributes == null)
                attributes = new ArrayList<>();
            attributes.add(attribute);
        }

        public ArrayList<XMLAttribute> getAttributes() {
            return attributes;
        }

        public void setAttributes(ArrayList<XMLAttribute> attributes) {
            this.attributes = attributes;
        }

        public boolean hasContent() {
            return content != null;
        }

        public ArrayList<XMLContent> getContent() {
            return content;
        }

        public void setContent(ArrayList<XMLContent> content) {
            this.content = content;
        }

        public void addContent(XMLContent xml) {
            if (content == null)
                content = new ArrayList<>();
            content.add(xml);
        }

        @Override
        public boolean isTag() {
            return true;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('<');
            sb.append(element);
            if (hasAttributes()) {
                sb.append(' ');
                for (int i = 0; i < attributes.size(); ++i) {
                    sb.append(attributes.get(i));
                    if (i != attributes.size() - 1)
                        sb.append(' ');
                }
            }
            if (hasContent()) {
                sb.append('>');
                //System.out.println("Element: " + element + " content: " + content);
                for (XMLContent c : content) {
                    sb.append(c);
                }
                sb.append("</");
                sb.append(element);
                sb.append(">");
            } else {
                sb.append("/>");
            }
            return sb.toString();
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONArray.java
  visible: true
  text: |-
    package converter.JSONComponents;

    import java.util.ArrayList;

    public class JSONArray extends JSONContainer {
        private final ArrayList<JSONComponent> elements;

        public JSONArray() {
            elements = new ArrayList<>();
        }

        public JSONComponent[] getElements() {
            return (JSONComponent[]) elements.toArray();
        }

        public void add(JSONComponent jc) {
            elements.add(jc);
        }


        @Override
        public boolean isJSONPrimitive() {
            return false;
        }

        @Override
        public boolean isJSONArray() {
            return true;
        }

        @Override
        public String JSONRepresentation() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            for (int i = 0; i < elements.size(); ++i) {
                sb.append(' ');
                sb.append(elements.get(i).JSONRepresentation());
                if (i != elements.size() - 1)
                    sb.append(',');
            }
            sb.append(']');
            return sb.toString();
        }
    }
  learner_created: true
- name: src/converter/JSONParser/JSONLexer.java
  visible: true
  text: |-
    package converter.JSONParser;

    import converter.JSONComponents.JSONBoolean;
    import converter.JSONComponents.JSONCharacter;
    import converter.JSONComponents.JSONComponent;
    import converter.JSONComponents.JSONFloat;
    import converter.JSONComponents.JSONInteger;
    import converter.JSONComponents.JSONNull;
    import converter.JSONComponents.JSONNumber;
    import converter.JSONComponents.JSONString;
    import converter.Pair;

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Optional;
    import java.util.stream.Collectors;
    import java.util.stream.IntStream;
    import java.util.stream.Stream;

    public class JSONLexer {
        private static HashSet<Character> JSONWhitespace;
        private static HashSet<Character> JSONSyntax;
        private static HashSet<Character> JSONNumberCharacters;

        static {
            JSONWhitespace = Stream.of(' ', '\t', '\b', '\n', '\r')
                    .collect(Collectors.toCollection(HashSet::new));
            JSONSyntax = Arrays.stream(JSONCharacter.values())
                    .map(JSONCharacter::getField)
                    .collect(Collectors.toCollection(HashSet::new));
            JSONNumberCharacters = Stream.concat(
                    Stream.of('-', 'e', '.'),
                    IntStream.range(0, 10)
                            .mapToObj(i -> Character.valueOf((char) ('0' + i))))
                    .collect(Collectors.toCollection(HashSet::new));

        }

        public static Optional<Pair<JSONString, String>> lexString(String input) {
            StringBuilder sb = new StringBuilder();
            if (JSONCharacter.JSON_QUOTE.getField() != input.charAt(0))
                return Optional.empty();
            input = input.substring(1);
            input.chars()
                    .takeWhile(c -> JSONCharacter.JSON_QUOTE.getField() != (char) c)
                    .forEachOrdered(c -> sb.append((char) c));
            if (sb.length() == input.length())
                throw new IllegalArgumentException("Failed to reach terminal \" at end of input String");
            else
                return Optional.of(new Pair<>(new JSONString(sb.toString()), input.substring(sb.length() + 1)));
        }

        public static Optional<Pair<JSONNumber, String>> lexNumber(String input) {
            StringBuilder sb = new StringBuilder();
            input.chars().takeWhile(c -> JSONNumberCharacters.contains((char) c))
                    .forEachOrdered(c -> sb.append((char) c));
            input = input.substring(sb.length());
            if (sb.length() == 0)
                return Optional.empty();
            else {
                JSONNumber jn;
                if (sb.toString().contains("."))
                    jn = new JSONFloat(Double.parseDouble(sb.toString()));
                else
                    jn = new JSONInteger(Integer.parseInt(sb.toString()));
                return Optional.of(new Pair<>(jn, input));
            }
        }

        public static Optional<Pair<JSONBoolean, String>> lexBoolean(String input) {
            if (input.startsWith("true"))
                return Optional.of(new Pair<>(new JSONBoolean(true), input.substring(4)));
            else if (input.startsWith("false"))
                return Optional.of(new Pair<>(new JSONBoolean(false), input.substring(5)));
            else
                return Optional.empty();
        }

        public static Optional<String> lexNull(String input) {
            if (input.startsWith("null"))
                return Optional.of(input.substring(4));
            else
                return Optional.empty();
        }

        public static List<JSONComponent> lex(String input) {
            List<JSONComponent> tokens = new ArrayList<>();
            while (!input.isEmpty()) {
                var jsonString = lexString(input);
                if (jsonString.isPresent()) {
                    tokens.add(jsonString.get().getFirst());
                    input = jsonString.get().getSecond();
                    continue;
                }
                var jsonNumber = lexNumber(input);
                if (jsonNumber.isPresent()) {
                    tokens.add(jsonNumber.get().getFirst());
                    input = jsonNumber.get().getSecond();
                    continue;
                }
                var jsonBoolean = lexBoolean(input);
                if (jsonBoolean.isPresent()) {
                    tokens.add(jsonBoolean.get().getFirst());
                    input = jsonBoolean.get().getSecond();
                    continue;
                }
                var jsonNull = lexNull(input);
                if (jsonNull.isPresent()) {
                    tokens.add(new JSONNull());
                    input = jsonNull.get();
                    continue;
                }
                char leadChar = input.charAt(0);
                input = input.substring(1);
                if (JSONWhitespace.contains(leadChar))
                    continue;
                else if (JSONSyntax.contains(leadChar)) {
                    tokens.add(JSONCharacter.charLookup(leadChar).get());
                } else {
                    throw new IllegalArgumentException("Unexpected character: " + leadChar);
                }
            }
            return tokens;
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONContainer.java
  visible: true
  text: |-
    package converter.JSONComponents;

    public abstract class JSONContainer implements JSONComponent {
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONObject.java
  visible: true
  text: |-
    package converter.JSONComponents;

    import java.util.LinkedHashMap;

    public class JSONObject extends JSONContainer {
        private final LinkedHashMap<JSONString, JSONComponent> mappings;

        public JSONObject() {
            mappings = new LinkedHashMap<>();
        }

        public boolean hasField(String field) {
            return mappings.containsKey(new JSONString(field));
        }

        public JSONComponent getValue(String field) {
            return mappings.get(new JSONString(field));
        }

        public LinkedHashMap<JSONString, JSONComponent> getMappings() {
            return mappings;
        }

        public void add(JSONString key, JSONComponent value) {
            mappings.put(key, value);
        }

        @Override
        public boolean isJSONPrimitive() {
            return false;
        }

        @Override
        public boolean isJSONObject() {
            return true;
        }

        @Override
        public String JSONRepresentation() {
            StringBuilder sb = new StringBuilder();
            sb.append('{');
            var es = mappings.entrySet();
            for (var it = es.iterator(); it.hasNext(); ) {
                var entry = it.next();
                sb.append(" " + entry.getKey().JSONRepresentation());
                sb.append(" :");
                sb.append(" " + entry.getValue().JSONRepresentation());
                if (it.hasNext())
                    sb.append(',');
            }
            sb.append('}');
            return sb.toString();
        }
    }
  learner_created: true
- name: src/converter/JSONParser/JSONParser.java
  visible: true
  text: |-
    package converter.JSONParser;

    import converter.JSONComponents.JSONArray;
    import converter.JSONComponents.JSONCharacter;
    import converter.JSONComponents.JSONComponent;
    import converter.JSONComponents.JSONObject;
    import converter.JSONComponents.JSONString;
    import converter.Pair;

    import java.util.List;

    public class JSONParser {
        public static Pair<? extends JSONComponent, Integer> parse(List<JSONComponent> tokens, int currentIndex) {
            JSONComponent currentToken = tokens.get(currentIndex);
            if (currentToken.getClass() == JSONCharacter.class) {
                if (currentToken == JSONCharacter.JSON_BRACKET_LEFT)
                    return parseArray(tokens, ++currentIndex);
                else if (currentToken == JSONCharacter.JSON_BRACE_LEFT)
                    return parseObject(tokens, ++currentIndex);
            }
            return new Pair<>(currentToken, ++currentIndex);
        }

        public static Pair<JSONArray, Integer> parseArray(List<JSONComponent> tokens, int currentIndex) {
            JSONArray ja = new JSONArray();
            if (tokens == null || tokens.isEmpty())
                throw new IllegalArgumentException("List tokens is invalid!");
            if (currentIndex >= tokens.size())
                throw new IllegalArgumentException("Expected terminating ']'");
            if (tokens.get(currentIndex) == JSONCharacter.JSON_BRACKET_RIGHT)
                return new Pair<>(ja, currentIndex);
            while (true) {
                var pair = parse(tokens, currentIndex);
                ja.add(pair.getFirst());
                currentIndex = pair.getSecond();
                JSONComponent currentToken = tokens.get(currentIndex);
                if (currentToken.getClass() == JSONCharacter.class) {
                    if (currentToken == JSONCharacter.JSON_BRACKET_RIGHT)
                        return new Pair<>(ja, ++currentIndex);
                    else if (currentToken != JSONCharacter.JSON_COMMA)
                        throw new IllegalArgumentException("Expected comma character after object in JSONArray!");
                    else
                        ++currentIndex;
                } else
                    throw new IllegalArgumentException("Expected JSONCharacter ',' or ']' after array entry");
            }

        }

        public static Pair<JSONObject, Integer> parseObject(List<JSONComponent> tokens, int currentIndex) {
            JSONObject obj = new JSONObject();
            JSONComponent currentToken = tokens.get(currentIndex);
            if (currentToken.getClass() == JSONCharacter.class && currentToken == JSONCharacter.JSON_BRACE_RIGHT)
                return new Pair<>(obj, ++currentIndex);
            while (true) {
                var key = tokens.get(currentIndex);
                if (key.getClass() == JSONString.class)
                    ++currentIndex;
                else
                    throw new IllegalArgumentException("Expected String key in JSONObject, found " + key.getClass());
                if (tokens.get(currentIndex).getClass() != JSONCharacter.class || tokens.get(currentIndex) != JSONCharacter.JSON_COLON)
                    throw new IllegalArgumentException("Expected colon after key in JSONObject, found " + tokens.get(currentIndex).getClass());
                var value = parse(tokens, ++currentIndex);
                obj.add((JSONString) key, value.getFirst());
                currentIndex = value.getSecond();
                currentToken = tokens.get(currentIndex);
                if (currentToken.getClass() == JSONCharacter.class && currentToken == JSONCharacter.JSON_BRACE_RIGHT)
                    return new Pair<>(obj, ++currentIndex);
                else if (currentToken.getClass() != JSONCharacter.class || currentToken != JSONCharacter.JSON_COMMA)
                    throw new IllegalArgumentException("Expected comma after pair in JSONObject, found " + currentToken.getClass());
                else
                    ++currentIndex;
            }
        }
    }
  learner_created: true
- name: src/converter/JSONComponents/JSONCharacter.java
  visible: true
  text: |-
    package converter.JSONComponents;

    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Optional;
    import java.util.function.Function;
    import java.util.stream.Collectors;

    public enum JSONCharacter implements JSONComponent{
        JSON_COMMA(','),
        JSON_COLON(':'),
        JSON_BRACKET_LEFT('['),
        JSON_BRACKET_RIGHT(']'),
        JSON_BRACE_LEFT('{'),
        JSON_BRACE_RIGHT('}'),
        JSON_QUOTE('"');

        private static final Map<Character, JSONCharacter> charToJSONMap;

        static {
            charToJSONMap = Arrays.stream(JSONCharacter.values())
                    .collect(Collectors.toMap(JSONCharacter::getField, Function.identity(), (e, r) -> e, HashMap::new));
        }

        private final char field;

        JSONCharacter(char field) {
            this.field = field;
        }

        public char getField() {
            return this.field;
        }

        public static Optional<JSONCharacter> charLookup(char c) {
            return charToJSONMap.containsKey(c) ? Optional.of(charToJSONMap.get(c)) : Optional.empty();
        }

        @Override
        public String toString() {
            return JSONRepresentation();
        }

        @Override
        public String JSONRepresentation() {
            return Character.toString(this.field);
        }
    }
  learner_created: true
- name: test.txt
  visible: true
  text: |-
    <transaction>
        <id>6753322</id>
        <number region="Russia">8-900-999-00-00</number>
        <email>
            <to>to_example@gmail.com</to>
            <from>from_example@gmail.com</from>
            <subject>Project discussion</subject>
            <body font="Verdana">Body message</body>
            <date day="12" month="12" year="2018"/>
        </email>
    </transaction>
  learner_created: false
feedback_link: https://hyperskill.org/projects/61/stages/332/implement
status: Solved
feedback:
  message: Congratulations! Continue on <a href="https://hyperskill.org/projects/61/stages/332/implement">JetBrains
    Academy</a>
  time: Sun, 29 Aug 2021 21:09:44 UTC
record: 4
